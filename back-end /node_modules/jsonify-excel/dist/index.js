'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XLSX = require('xlsx');

module.exports = function () {
  _createClass(_class, [{
    key: 'defaultOptions',
    get: function get() {
      return {
        automap: false,
        sheet: 0,
        start: 2,
        condition: function condition(cell) {
          return !!cell('A');
        }
      };
    }
  }]);

  function _class(filePath) {
    _classCallCheck(this, _class);

    this.workbook = XLSX.readFile(filePath);
  }

  _createClass(_class, [{
    key: 'is',
    value: function is(value, type) {
      return Object.prototype.toString.call(value).match(/ (.+)]/)[1].toLowerCase() === type;
    }
  }, {
    key: 'parse',
    value: function parse(value, cellValue) {
      var _this = this;

      switch (true) {
        case this.is(value, 'string'):
          {
            var md = value.match(/^\*([A-Z]+)$/);
            return md ? cellValue(md[1]) : value;
          }
        case this.is(value, 'object'):
          {
            var _ret = function () {
              var data = {};
              Object.keys(value).forEach(function (key) {
                data[_this.parse(key, cellValue)] = _this.parse(value[key], cellValue);
              });
              return {
                v: data
              };
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
          }
        case this.is(value, 'array'):
          return value.map(function (v) {
            return _this.parse(v, cellValue);
          });
        case this.is(value, 'function'):
          return value(cellValue, this.currentRow);
        default:
          return value;
      }
    }
  }, {
    key: 'cellValueGetter',
    value: function cellValueGetter(row) {
      var _this2 = this;

      return function (col) {
        var cell = _this2.worksheet[col + row];
        if (cell === undefined) return cell;
        switch (cell.t) {
          case 'b':
            return cell.v;
          case 'e':
            return new Error(cell.w);
          default:
            return cell.w;
        }
      };
    }
  }, {
    key: 'collectDate',
    value: function collectDate(dataSet, map) {
      var cellValue = this.cellValueGetter(this.currentRow);
      switch (this.condition(cellValue, this.currentRow)) {
        case true:
          {
            var data = this.parse(map, cellValue);
            if (dataSet.push) dataSet.push(data);else Object.assign(dataSet, data);
            break;
          }
        case null:
          // skip this turn
          break;
        case false:
        default:
          return dataSet;
      }
      this.currentRow++;
      return this.collectDate(dataSet, map);
    }
  }, {
    key: 'getHeaderMap',
    value: function getHeaderMap() {
      var cellValue = this.cellValueGetter(this.currentRow++);
      var map = {};
      for (var i = 0;; i++) {
        var col = XLSX.utils.encode_col(i);
        var value = cellValue(col);
        if (!value) return [map];
        map[value] = '*' + col;
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON(config, map) {
      var _Object$assign = Object.assign({}, this.defaultOptions, config);

      var automap = _Object$assign.automap;
      var sheet = _Object$assign.sheet;
      var start = _Object$assign.start;
      var condition = _Object$assign.condition;

      var sheetName = this.is(sheet, 'string') ? sheet : this.workbook.SheetNames[sheet];
      this.worksheet = this.workbook.Sheets[sheetName];
      this.currentRow = start;
      this.condition = condition;
      this.map = automap ? this.getHeaderMap() : map;
      return this.is(this.map, 'array') ? this.collectDate([], this.map[0]) : this.collectDate({}, this.map);
    }
  }]);

  return _class;
}();